// This code was autogenerated with dbus-codegen-rust, see https://github.com/diwic/dbus-rs

use dbus as dbus;
use dbus::arg;
use dbus::Message;
use dbus_tokio::AConnection;
use dbus::Error as DbusError;
use futures::Future;
use futures::future::IntoFuture;
use std::boxed::Box;
use std::rc::Rc;

pub trait OrgFreedesktopDBusIntrospectable {
    type Err;
    fn introspect(&self) -> Box<dyn Future<Item=String, Error=Self::Err>>;
}

impl<'a> OrgFreedesktopDBusIntrospectable for dbus::ConnPath<'a, Rc<AConnection>> {
    type Err = DbusError;

    fn introspect(&self) -> Box<dyn Future<Item=String, Error=Self::Err>> {
        let msg = Message::method_call(&self.dest, &self.path, &"org.freedesktop.DBus.Introspectable".into(), &"Introspect".into());
        let introspect_fut = self.conn
            .method_call(msg)
            .into_future()
            .map_err(|_e| DbusError::new_custom("org.freedesktop.DBus.Failed", "failed to call method"))
            .and_then(|amethodcall| {
                amethodcall
                    .and_then(|mut m| {
                        let res = m.as_result();
                        if let Err(e) = res {
                            Err(e)
                        } else {
                            Ok(m)
                        }
                    }).and_then(|_m| {
                        let mut i = _m.iter_init();
                        let xml: String =
                        match i.read() {
                            Err(_e) => {
                                return Err(DbusError::new_custom("org.freedesktop.DBus.Failed", "type mismatch"));
                            },
                            Ok(o) => o
                        };
                        Ok(xml)
                    })
        });
        Box::new(introspect_fut)
    }
}

pub trait Manager {
    type Err;
    fn get_properties(&self) -> Box<dyn Future<Item=::std::collections::HashMap<String, arg::Variant<Box<dyn arg::RefArg + 'static>>>, Error=Self::Err>>;
    fn set_property<I1: arg::Arg + arg::Append>(&self, name: &str, value: arg::Variant<I1>) -> Box<dyn Future<Item=(), Error=Self::Err>>;
    fn get_technologies(&self) -> Box<dyn Future<Item=Vec<(dbus::Path<'static>, ::std::collections::HashMap<String, arg::Variant<Box<dyn arg::RefArg + 'static>>>)>, Error=Self::Err>>;
    fn remove_provider(&self, provider: dbus::Path) -> Box<dyn Future<Item=(), Error=Self::Err>>;
    fn get_services(&self) -> Box<dyn Future<Item=Vec<(dbus::Path<'static>, ::std::collections::HashMap<String, arg::Variant<Box<dyn arg::RefArg + 'static>>>)>, Error=Self::Err>>;
    fn get_peers(&self) -> Box<dyn Future<Item=Vec<(dbus::Path<'static>, ::std::collections::HashMap<String, arg::Variant<Box<dyn arg::RefArg + 'static>>>)>, Error=Self::Err>>;
    fn connect_provider(&self, provider: ::std::collections::HashMap<&str, arg::Variant<Box<dyn arg::RefArg>>>) -> Box<dyn Future<Item=dbus::Path<'static>, Error=Self::Err>>;
    fn register_agent(&self, path: dbus::Path) -> Box<dyn Future<Item=(), Error=Self::Err>>;
    fn unregister_agent(&self, path: dbus::Path) -> Box<dyn Future<Item=(), Error=Self::Err>>;
    fn register_counter(&self, path: dbus::Path, accuracy: u32, period: u32) -> Box<dyn Future<Item=(), Error=Self::Err>>;
    fn unregister_counter(&self, path: dbus::Path) -> Box<dyn Future<Item=(), Error=Self::Err>>;
    fn create_session(&self, settings: ::std::collections::HashMap<&str, arg::Variant<Box<dyn arg::RefArg>>>, notifier: dbus::Path) -> Box<dyn Future<Item=dbus::Path<'static>, Error=Self::Err>>;
    fn destroy_session(&self, session: dbus::Path) -> Box<dyn Future<Item=(), Error=Self::Err>>;
    fn request_private_network(&self) -> Box<dyn Future<Item=(dbus::Path<'static>, ::std::collections::HashMap<String, arg::Variant<Box<dyn arg::RefArg + 'static>>>, dbus::OwnedFd), Error=Self::Err>>;
    fn release_private_network(&self, path: dbus::Path) -> Box<dyn Future<Item=(), Error=Self::Err>>;
    fn register_peer_service(&self, specification: ::std::collections::HashMap<&str, arg::Variant<Box<dyn arg::RefArg>>>, master: bool) -> Box<dyn Future<Item=(), Error=Self::Err>>;
    fn unregister_peer_service(&self, specification: ::std::collections::HashMap<&str, arg::Variant<Box<dyn arg::RefArg>>>) -> Box<dyn Future<Item=(), Error=Self::Err>>;
}

impl<'a> Manager for dbus::ConnPath<'a, Rc<AConnection>> {
    type Err = DbusError;

    fn get_properties(&self) -> Box<dyn Future<Item=::std::collections::HashMap<String, arg::Variant<Box<dyn arg::RefArg + 'static>>>, Error=Self::Err>> {
        let msg = Message::method_call(&self.dest, &self.path, &"net.connman.Manager".into(), &"GetProperties".into());
        let get_properties_fut = self.conn
            .method_call(msg)
            .into_future()
            .map_err(|_e| DbusError::new_custom("org.freedesktop.DBus.Failed", "failed to call method"))
            .and_then(|amethodcall| {
                amethodcall
                    .and_then(|mut m| {
                        let res = m.as_result();
                        if let Err(e) = res {
                            Err(e)
                        } else {
                            Ok(m)
                        }
                    }).and_then(|_m| {
                        let mut i = _m.iter_init();
                        let properties: ::std::collections::HashMap<String, arg::Variant<Box<dyn arg::RefArg + 'static>>> =
                        match i.read() {
                            Err(_e) => {
                                return Err(DbusError::new_custom("org.freedesktop.DBus.Failed", "type mismatch"));
                            },
                            Ok(o) => o
                        };
                        Ok(properties)
                    })
        });
        Box::new(get_properties_fut)
    }

    fn set_property<I1: arg::Arg + arg::Append>(&self, name: &str, value: arg::Variant<I1>) -> Box<dyn Future<Item=(), Error=Self::Err>> {
        let mut msg = Message::method_call(&self.dest, &self.path, &"net.connman.Manager".into(), &"SetProperty".into());
        {
            let mut i = arg::IterAppend::new(&mut msg);
            i.append(name);
            i.append(value);
        }
        let set_property_fut = self.conn
            .method_call(msg)
            .into_future()
            .map_err(|_e| DbusError::new_custom("org.freedesktop.DBus.Failed", "failed to call method"))
            .and_then(|amethodcall| {
                amethodcall
                    .and_then(|mut m| {
                        let res = m.as_result();
                        if let Err(e) = res {
                            Err(e)
                        } else {
                            Ok(m)
                        }
                    }).and_then(|_m| {
                        Ok(())
                    })
        });
        Box::new(set_property_fut)
    }

    fn get_technologies(&self) -> Box<dyn Future<Item=Vec<(dbus::Path<'static>, ::std::collections::HashMap<String, arg::Variant<Box<dyn arg::RefArg + 'static>>>)>, Error=Self::Err>> {
        let msg = Message::method_call(&self.dest, &self.path, &"net.connman.Manager".into(), &"GetTechnologies".into());
        let get_technologies_fut = self.conn
            .method_call(msg)
            .into_future()
            .map_err(|_e| DbusError::new_custom("org.freedesktop.DBus.Failed", "failed to call method"))
            .and_then(|amethodcall| {
                amethodcall
                    .and_then(|mut m| {
                        let res = m.as_result();
                        if let Err(e) = res {
                            Err(e)
                        } else {
                            Ok(m)
                        }
                    }).and_then(|_m| {
                        let mut i = _m.iter_init();
                        let technologies: Vec<(dbus::Path<'static>, ::std::collections::HashMap<String, arg::Variant<Box<dyn arg::RefArg + 'static>>>)> =
                        match i.read() {
                            Err(_e) => {
                                return Err(DbusError::new_custom("org.freedesktop.DBus.Failed", "type mismatch"));
                            },
                            Ok(o) => o
                        };
                        Ok(technologies)
                    })
        });
        Box::new(get_technologies_fut)
    }

    fn remove_provider(&self, provider: dbus::Path) -> Box<dyn Future<Item=(), Error=Self::Err>> {
        let mut msg = Message::method_call(&self.dest, &self.path, &"net.connman.Manager".into(), &"RemoveProvider".into());
        {
            let mut i = arg::IterAppend::new(&mut msg);
            i.append(provider);
        }
        let remove_provider_fut = self.conn
            .method_call(msg)
            .into_future()
            .map_err(|_e| DbusError::new_custom("org.freedesktop.DBus.Failed", "failed to call method"))
            .and_then(|amethodcall| {
                amethodcall
                    .and_then(|mut m| {
                        let res = m.as_result();
                        if let Err(e) = res {
                            Err(e)
                        } else {
                            Ok(m)
                        }
                    }).and_then(|_m| {
                        Ok(())
                    })
        });
        Box::new(remove_provider_fut)
    }

    fn get_services(&self) -> Box<dyn Future<Item=Vec<(dbus::Path<'static>, ::std::collections::HashMap<String, arg::Variant<Box<dyn arg::RefArg + 'static>>>)>, Error=Self::Err>> {
        let msg = Message::method_call(&self.dest, &self.path, &"net.connman.Manager".into(), &"GetServices".into());
        let get_services_fut = self.conn
            .method_call(msg)
            .into_future()
            .map_err(|_e| DbusError::new_custom("org.freedesktop.DBus.Failed", "failed to call method"))
            .and_then(|amethodcall| {
                amethodcall
                    .and_then(|mut m| {
                        let res = m.as_result();
                        if let Err(e) = res {
                            Err(e)
                        } else {
                            Ok(m)
                        }
                    }).and_then(|_m| {
                        let mut i = _m.iter_init();
                        let services: Vec<(dbus::Path<'static>, ::std::collections::HashMap<String, arg::Variant<Box<dyn arg::RefArg + 'static>>>)> =
                        match i.read() {
                            Err(_e) => {
                                return Err(DbusError::new_custom("org.freedesktop.DBus.Failed", "type mismatch"));
                            },
                            Ok(o) => o
                        };
                        Ok(services)
                    })
        });
        Box::new(get_services_fut)
    }

    fn get_peers(&self) -> Box<dyn Future<Item=Vec<(dbus::Path<'static>, ::std::collections::HashMap<String, arg::Variant<Box<dyn arg::RefArg + 'static>>>)>, Error=Self::Err>> {
        let msg = Message::method_call(&self.dest, &self.path, &"net.connman.Manager".into(), &"GetPeers".into());
        let get_peers_fut = self.conn
            .method_call(msg)
            .into_future()
            .map_err(|_e| DbusError::new_custom("org.freedesktop.DBus.Failed", "failed to call method"))
            .and_then(|amethodcall| {
                amethodcall
                    .and_then(|mut m| {
                        let res = m.as_result();
                        if let Err(e) = res {
                            Err(e)
                        } else {
                            Ok(m)
                        }
                    }).and_then(|_m| {
                        let mut i = _m.iter_init();
                        let peers: Vec<(dbus::Path<'static>, ::std::collections::HashMap<String, arg::Variant<Box<dyn arg::RefArg + 'static>>>)> =
                        match i.read() {
                            Err(_e) => {
                                return Err(DbusError::new_custom("org.freedesktop.DBus.Failed", "type mismatch"));
                            },
                            Ok(o) => o
                        };
                        Ok(peers)
                    })
        });
        Box::new(get_peers_fut)
    }

    fn connect_provider(&self, provider: ::std::collections::HashMap<&str, arg::Variant<Box<dyn arg::RefArg>>>) -> Box<dyn Future<Item=dbus::Path<'static>, Error=Self::Err>> {
        let mut msg = Message::method_call(&self.dest, &self.path, &"net.connman.Manager".into(), &"ConnectProvider".into());
        {
            let mut i = arg::IterAppend::new(&mut msg);
            i.append(provider);
        }
        let connect_provider_fut = self.conn
            .method_call(msg)
            .into_future()
            .map_err(|_e| DbusError::new_custom("org.freedesktop.DBus.Failed", "failed to call method"))
            .and_then(|amethodcall| {
                amethodcall
                    .and_then(|mut m| {
                        let res = m.as_result();
                        if let Err(e) = res {
                            Err(e)
                        } else {
                            Ok(m)
                        }
                    }).and_then(|_m| {
                        let mut i = _m.iter_init();
                        let path: dbus::Path<'static> =
                        match i.read() {
                            Err(_e) => {
                                return Err(DbusError::new_custom("org.freedesktop.DBus.Failed", "type mismatch"));
                            },
                            Ok(o) => o
                        };
                        Ok(path)
                    })
        });
        Box::new(connect_provider_fut)
    }

    fn register_agent(&self, path: dbus::Path) -> Box<dyn Future<Item=(), Error=Self::Err>> {
        let mut msg = Message::method_call(&self.dest, &self.path, &"net.connman.Manager".into(), &"RegisterAgent".into());
        {
            let mut i = arg::IterAppend::new(&mut msg);
            i.append(path);
        }
        let register_agent_fut = self.conn
            .method_call(msg)
            .into_future()
            .map_err(|_e| DbusError::new_custom("org.freedesktop.DBus.Failed", "failed to call method"))
            .and_then(|amethodcall| {
                amethodcall
                    .and_then(|mut m| {
                        let res = m.as_result();
                        if let Err(e) = res {
                            Err(e)
                        } else {
                            Ok(m)
                        }
                    }).and_then(|_m| {
                        Ok(())
                    })
        });
        Box::new(register_agent_fut)
    }

    fn unregister_agent(&self, path: dbus::Path) -> Box<dyn Future<Item=(), Error=Self::Err>> {
        let mut msg = Message::method_call(&self.dest, &self.path, &"net.connman.Manager".into(), &"UnregisterAgent".into());
        {
            let mut i = arg::IterAppend::new(&mut msg);
            i.append(path);
        }
        let unregister_agent_fut = self.conn
            .method_call(msg)
            .into_future()
            .map_err(|_e| DbusError::new_custom("org.freedesktop.DBus.Failed", "failed to call method"))
            .and_then(|amethodcall| {
                amethodcall
                    .and_then(|mut m| {
                        let res = m.as_result();
                        if let Err(e) = res {
                            Err(e)
                        } else {
                            Ok(m)
                        }
                    }).and_then(|_m| {
                        Ok(())
                    })
        });
        Box::new(unregister_agent_fut)
    }

    fn register_counter(&self, path: dbus::Path, accuracy: u32, period: u32) -> Box<dyn Future<Item=(), Error=Self::Err>> {
        let mut msg = Message::method_call(&self.dest, &self.path, &"net.connman.Manager".into(), &"RegisterCounter".into());
        {
            let mut i = arg::IterAppend::new(&mut msg);
            i.append(path);
            i.append(accuracy);
            i.append(period);
        }
        let register_counter_fut = self.conn
            .method_call(msg)
            .into_future()
            .map_err(|_e| DbusError::new_custom("org.freedesktop.DBus.Failed", "failed to call method"))
            .and_then(|amethodcall| {
                amethodcall
                    .and_then(|mut m| {
                        let res = m.as_result();
                        if let Err(e) = res {
                            Err(e)
                        } else {
                            Ok(m)
                        }
                    }).and_then(|_m| {
                        Ok(())
                    })
        });
        Box::new(register_counter_fut)
    }

    fn unregister_counter(&self, path: dbus::Path) -> Box<dyn Future<Item=(), Error=Self::Err>> {
        let mut msg = Message::method_call(&self.dest, &self.path, &"net.connman.Manager".into(), &"UnregisterCounter".into());
        {
            let mut i = arg::IterAppend::new(&mut msg);
            i.append(path);
        }
        let unregister_counter_fut = self.conn
            .method_call(msg)
            .into_future()
            .map_err(|_e| DbusError::new_custom("org.freedesktop.DBus.Failed", "failed to call method"))
            .and_then(|amethodcall| {
                amethodcall
                    .and_then(|mut m| {
                        let res = m.as_result();
                        if let Err(e) = res {
                            Err(e)
                        } else {
                            Ok(m)
                        }
                    }).and_then(|_m| {
                        Ok(())
                    })
        });
        Box::new(unregister_counter_fut)
    }

    fn create_session(&self, settings: ::std::collections::HashMap<&str, arg::Variant<Box<dyn arg::RefArg>>>, notifier: dbus::Path) -> Box<dyn Future<Item=dbus::Path<'static>, Error=Self::Err>> {
        let mut msg = Message::method_call(&self.dest, &self.path, &"net.connman.Manager".into(), &"CreateSession".into());
        {
            let mut i = arg::IterAppend::new(&mut msg);
            i.append(settings);
            i.append(notifier);
        }
        let create_session_fut = self.conn
            .method_call(msg)
            .into_future()
            .map_err(|_e| DbusError::new_custom("org.freedesktop.DBus.Failed", "failed to call method"))
            .and_then(|amethodcall| {
                amethodcall
                    .and_then(|mut m| {
                        let res = m.as_result();
                        if let Err(e) = res {
                            Err(e)
                        } else {
                            Ok(m)
                        }
                    }).and_then(|_m| {
                        let mut i = _m.iter_init();
                        let session: dbus::Path<'static> =
                        match i.read() {
                            Err(_e) => {
                                return Err(DbusError::new_custom("org.freedesktop.DBus.Failed", "type mismatch"));
                            },
                            Ok(o) => o
                        };
                        Ok(session)
                    })
        });
        Box::new(create_session_fut)
    }

    fn destroy_session(&self, session: dbus::Path) -> Box<dyn Future<Item=(), Error=Self::Err>> {
        let mut msg = Message::method_call(&self.dest, &self.path, &"net.connman.Manager".into(), &"DestroySession".into());
        {
            let mut i = arg::IterAppend::new(&mut msg);
            i.append(session);
        }
        let destroy_session_fut = self.conn
            .method_call(msg)
            .into_future()
            .map_err(|_e| DbusError::new_custom("org.freedesktop.DBus.Failed", "failed to call method"))
            .and_then(|amethodcall| {
                amethodcall
                    .and_then(|mut m| {
                        let res = m.as_result();
                        if let Err(e) = res {
                            Err(e)
                        } else {
                            Ok(m)
                        }
                    }).and_then(|_m| {
                        Ok(())
                    })
        });
        Box::new(destroy_session_fut)
    }

    fn request_private_network(&self) -> Box<dyn Future<Item=(dbus::Path<'static>, ::std::collections::HashMap<String, arg::Variant<Box<dyn arg::RefArg + 'static>>>, dbus::OwnedFd), Error=Self::Err>> {
        let msg = Message::method_call(&self.dest, &self.path, &"net.connman.Manager".into(), &"RequestPrivateNetwork".into());
        let request_private_network_fut = self.conn
            .method_call(msg)
            .into_future()
            .map_err(|_e| DbusError::new_custom("org.freedesktop.DBus.Failed", "failed to call method"))
            .and_then(|amethodcall| {
                amethodcall
                    .and_then(|mut m| {
                        let res = m.as_result();
                        if let Err(e) = res {
                            Err(e)
                        } else {
                            Ok(m)
                        }
                    }).and_then(|_m| {
                        let mut i = _m.iter_init();
                        let path: dbus::Path<'static> =
                        match i.read() {
                            Err(_e) => {
                                return Err(DbusError::new_custom("org.freedesktop.DBus.Failed", "type mismatch"));
                            },
                            Ok(o) => o
                        };
                        let settings: ::std::collections::HashMap<String, arg::Variant<Box<dyn arg::RefArg + 'static>>> =
                        match i.read() {
                            Err(_e) => {
                                return Err(DbusError::new_custom("org.freedesktop.DBus.Failed", "type mismatch"));
                            },
                            Ok(o) => o
                        };
                        let socket: dbus::OwnedFd =
                        match i.read() {
                            Err(_e) => {
                                return Err(DbusError::new_custom("org.freedesktop.DBus.Failed", "type mismatch"));
                            },
                            Ok(o) => o
                        };
                        Ok((path, settings, socket))
                    })
        });
        Box::new(request_private_network_fut)
    }

    fn release_private_network(&self, path: dbus::Path) -> Box<dyn Future<Item=(), Error=Self::Err>> {
        let mut msg = Message::method_call(&self.dest, &self.path, &"net.connman.Manager".into(), &"ReleasePrivateNetwork".into());
        {
            let mut i = arg::IterAppend::new(&mut msg);
            i.append(path);
        }
        let release_private_network_fut = self.conn
            .method_call(msg)
            .into_future()
            .map_err(|_e| DbusError::new_custom("org.freedesktop.DBus.Failed", "failed to call method"))
            .and_then(|amethodcall| {
                amethodcall
                    .and_then(|mut m| {
                        let res = m.as_result();
                        if let Err(e) = res {
                            Err(e)
                        } else {
                            Ok(m)
                        }
                    }).and_then(|_m| {
                        Ok(())
                    })
        });
        Box::new(release_private_network_fut)
    }

    fn register_peer_service(&self, specification: ::std::collections::HashMap<&str, arg::Variant<Box<dyn arg::RefArg>>>, master: bool) -> Box<dyn Future<Item=(), Error=Self::Err>> {
        let mut msg = Message::method_call(&self.dest, &self.path, &"net.connman.Manager".into(), &"RegisterPeerService".into());
        {
            let mut i = arg::IterAppend::new(&mut msg);
            i.append(specification);
            i.append(master);
        }
        let register_peer_service_fut = self.conn
            .method_call(msg)
            .into_future()
            .map_err(|_e| DbusError::new_custom("org.freedesktop.DBus.Failed", "failed to call method"))
            .and_then(|amethodcall| {
                amethodcall
                    .and_then(|mut m| {
                        let res = m.as_result();
                        if let Err(e) = res {
                            Err(e)
                        } else {
                            Ok(m)
                        }
                    }).and_then(|_m| {
                        Ok(())
                    })
        });
        Box::new(register_peer_service_fut)
    }

    fn unregister_peer_service(&self, specification: ::std::collections::HashMap<&str, arg::Variant<Box<dyn arg::RefArg>>>) -> Box<dyn Future<Item=(), Error=Self::Err>> {
        let mut msg = Message::method_call(&self.dest, &self.path, &"net.connman.Manager".into(), &"UnregisterPeerService".into());
        {
            let mut i = arg::IterAppend::new(&mut msg);
            i.append(specification);
        }
        let unregister_peer_service_fut = self.conn
            .method_call(msg)
            .into_future()
            .map_err(|_e| DbusError::new_custom("org.freedesktop.DBus.Failed", "failed to call method"))
            .and_then(|amethodcall| {
                amethodcall
                    .and_then(|mut m| {
                        let res = m.as_result();
                        if let Err(e) = res {
                            Err(e)
                        } else {
                            Ok(m)
                        }
                    }).and_then(|_m| {
                        Ok(())
                    })
        });
        Box::new(unregister_peer_service_fut)
    }
}

#[derive(Debug, Default)]
pub struct ManagerPropertyChanged {
    pub name: String,
    pub value: arg::Variant<Box<dyn arg::RefArg + 'static>>,
}

impl dbus::SignalArgs for ManagerPropertyChanged {
    const NAME: &'static str = "PropertyChanged";
    const INTERFACE: &'static str = "net.connman.Manager";
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.name, i);
        arg::RefArg::append(&self.value, i);
    }
    fn get(&mut self, i: &mut arg::Iter) -> Result<(), arg::TypeMismatchError> {
        self.name = i.read()?;
        self.value = i.read()?;
        Ok(())
    }
}

#[derive(Debug, Default)]
pub struct ManagerTechnologyAdded {
    pub path: dbus::Path<'static>,
    pub properties: ::std::collections::HashMap<String, arg::Variant<Box<dyn arg::RefArg + 'static>>>,
}

impl dbus::SignalArgs for ManagerTechnologyAdded {
    const NAME: &'static str = "TechnologyAdded";
    const INTERFACE: &'static str = "net.connman.Manager";
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.path, i);
        arg::RefArg::append(&self.properties, i);
    }
    fn get(&mut self, i: &mut arg::Iter) -> Result<(), arg::TypeMismatchError> {
        self.path = i.read()?;
        self.properties = i.read()?;
        Ok(())
    }
}

#[derive(Debug, Default)]
pub struct ManagerTechnologyRemoved {
    pub path: dbus::Path<'static>,
}

impl dbus::SignalArgs for ManagerTechnologyRemoved {
    const NAME: &'static str = "TechnologyRemoved";
    const INTERFACE: &'static str = "net.connman.Manager";
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.path, i);
    }
    fn get(&mut self, i: &mut arg::Iter) -> Result<(), arg::TypeMismatchError> {
        self.path = i.read()?;
        Ok(())
    }
}

#[derive(Debug, Default)]
pub struct ManagerServicesChanged {
    pub changed: Vec<(dbus::Path<'static>, ::std::collections::HashMap<String, arg::Variant<Box<dyn arg::RefArg + 'static>>>)>,
    pub removed: Vec<dbus::Path<'static>>,
}

impl dbus::SignalArgs for ManagerServicesChanged {
    const NAME: &'static str = "ServicesChanged";
    const INTERFACE: &'static str = "net.connman.Manager";
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.changed, i);
        arg::RefArg::append(&self.removed, i);
    }
    fn get(&mut self, i: &mut arg::Iter) -> Result<(), arg::TypeMismatchError> {
        self.changed = i.read()?;
        self.removed = i.read()?;
        Ok(())
    }
}

#[derive(Debug, Default)]
pub struct ManagerPeersChanged {
    pub changed: Vec<(dbus::Path<'static>, ::std::collections::HashMap<String, arg::Variant<Box<dyn arg::RefArg + 'static>>>)>,
    pub removed: Vec<dbus::Path<'static>>,
}

impl dbus::SignalArgs for ManagerPeersChanged {
    const NAME: &'static str = "PeersChanged";
    const INTERFACE: &'static str = "net.connman.Manager";
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.changed, i);
        arg::RefArg::append(&self.removed, i);
    }
    fn get(&mut self, i: &mut arg::Iter) -> Result<(), arg::TypeMismatchError> {
        self.changed = i.read()?;
        self.removed = i.read()?;
        Ok(())
    }
}

pub trait Clock {
    type Err;
    fn get_properties(&self) -> Box<dyn Future<Item=::std::collections::HashMap<String, arg::Variant<Box<dyn arg::RefArg + 'static>>>, Error=Self::Err>>;
    fn set_property<I1: arg::Arg + arg::Append>(&self, name: &str, value: arg::Variant<I1>) -> Box<dyn Future<Item=(), Error=Self::Err>>;
}

impl<'a> Clock for dbus::ConnPath<'a, Rc<AConnection>> {
    type Err = DbusError;

    fn get_properties(&self) -> Box<dyn Future<Item=::std::collections::HashMap<String, arg::Variant<Box<dyn arg::RefArg + 'static>>>, Error=Self::Err>> {
        let msg = Message::method_call(&self.dest, &self.path, &"net.connman.Clock".into(), &"GetProperties".into());
        let get_properties_fut = self.conn
            .method_call(msg)
            .into_future()
            .map_err(|_e| DbusError::new_custom("org.freedesktop.DBus.Failed", "failed to call method"))
            .and_then(|amethodcall| {
                amethodcall
                    .and_then(|mut m| {
                        let res = m.as_result();
                        if let Err(e) = res {
                            Err(e)
                        } else {
                            Ok(m)
                        }
                    }).and_then(|_m| {
                        let mut i = _m.iter_init();
                        let properties: ::std::collections::HashMap<String, arg::Variant<Box<dyn arg::RefArg + 'static>>> =
                        match i.read() {
                            Err(_e) => {
                                return Err(DbusError::new_custom("org.freedesktop.DBus.Failed", "type mismatch"));
                            },
                            Ok(o) => o
                        };
                        Ok(properties)
                    })
        });
        Box::new(get_properties_fut)
    }

    fn set_property<I1: arg::Arg + arg::Append>(&self, name: &str, value: arg::Variant<I1>) -> Box<dyn Future<Item=(), Error=Self::Err>> {
        let mut msg = Message::method_call(&self.dest, &self.path, &"net.connman.Clock".into(), &"SetProperty".into());
        {
            let mut i = arg::IterAppend::new(&mut msg);
            i.append(name);
            i.append(value);
        }
        let set_property_fut = self.conn
            .method_call(msg)
            .into_future()
            .map_err(|_e| DbusError::new_custom("org.freedesktop.DBus.Failed", "failed to call method"))
            .and_then(|amethodcall| {
                amethodcall
                    .and_then(|mut m| {
                        let res = m.as_result();
                        if let Err(e) = res {
                            Err(e)
                        } else {
                            Ok(m)
                        }
                    }).and_then(|_m| {
                        Ok(())
                    })
        });
        Box::new(set_property_fut)
    }
}

#[derive(Debug, Default)]
pub struct ClockPropertyChanged {
    pub name: String,
    pub value: arg::Variant<Box<dyn arg::RefArg + 'static>>,
}

impl dbus::SignalArgs for ClockPropertyChanged {
    const NAME: &'static str = "PropertyChanged";
    const INTERFACE: &'static str = "net.connman.Clock";
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.name, i);
        arg::RefArg::append(&self.value, i);
    }
    fn get(&mut self, i: &mut arg::Iter) -> Result<(), arg::TypeMismatchError> {
        self.name = i.read()?;
        self.value = i.read()?;
        Ok(())
    }
}
