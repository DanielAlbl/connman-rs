// This code was autogenerated with dbus-codegen-rust, see https://github.com/diwic/dbus-rs

use dbus as dbus;
use dbus::arg;
use dbus::Message;
use dbus_tokio::AConnection;
use dbus::Error as DbusError;
use futures::Future;
use futures::future::IntoFuture;
use std::boxed::Box;
use std::rc::Rc;

pub trait OrgFreedesktopDBusIntrospectable {
    type Err;
    fn introspect(&self) -> Box<dyn Future<Item=String, Error=Self::Err>>;
}

impl<'a> OrgFreedesktopDBusIntrospectable for dbus::ConnPath<'a, Rc<AConnection>> {
    type Err = DbusError;

    fn introspect(&self) -> Box<dyn Future<Item=String, Error=Self::Err>> {
        let msg = Message::method_call(&self.dest, &self.path, &"org.freedesktop.DBus.Introspectable".into(), &"Introspect".into());
        let introspect_fut = self.conn
            .method_call(msg)
            .into_future()
            .map_err(|_e| DbusError::new_custom("org.freedesktop.DBus.Failed", "failed to call method"))
            .and_then(|amethodcall| {
                amethodcall
                    .and_then(|mut m| {
                        let res = m.as_result();
                        if let Err(e) = res {
                            Err(e)
                        } else {
                            Ok(m)
                        }
                    }).and_then(|_m| {
                        let mut i = _m.iter_init();
                        let xml: String =
                        match i.read() {
                            Err(_e) => {
                                return Err(DbusError::new_custom("org.freedesktop.DBus.Failed", "type mismatch"));
                            },
                            Ok(o) => o
                        };
                        Ok(xml)
                    })
        });
        Box::new(introspect_fut)
    }
}

pub trait Service {
    type Err;
    fn get_properties(&self) -> Box<dyn Future<Item=::std::collections::HashMap<String, arg::Variant<Box<dyn arg::RefArg + 'static>>>, Error=Self::Err>>;
    fn set_property<I1: arg::Arg + arg::Append>(&self, name: &str, value: arg::Variant<I1>) -> Box<dyn Future<Item=(), Error=Self::Err>>;
    fn clear_property(&self, name: &str) -> Box<dyn Future<Item=(), Error=Self::Err>>;
    fn connect(&self) -> Box<dyn Future<Item=(), Error=Self::Err>>;
    fn disconnect(&self) -> Box<dyn Future<Item=(), Error=Self::Err>>;
    fn remove(&self) -> Box<dyn Future<Item=(), Error=Self::Err>>;
    fn move_before(&self, service: dbus::Path) -> Box<dyn Future<Item=(), Error=Self::Err>>;
    fn move_after(&self, service: dbus::Path) -> Box<dyn Future<Item=(), Error=Self::Err>>;
    fn reset_counters(&self) -> Box<dyn Future<Item=(), Error=Self::Err>>;
}

impl<'a> Service for dbus::ConnPath<'a, Rc<AConnection>> {
    type Err = DbusError;

    fn get_properties(&self) -> Box<dyn Future<Item=::std::collections::HashMap<String, arg::Variant<Box<dyn arg::RefArg + 'static>>>, Error=Self::Err>> {
        let msg = Message::method_call(&self.dest, &self.path, &"net.connman.Service".into(), &"GetProperties".into());
        let get_properties_fut = self.conn
            .method_call(msg)
            .into_future()
            .map_err(|_e| DbusError::new_custom("org.freedesktop.DBus.Failed", "failed to call method"))
            .and_then(|amethodcall| {
                amethodcall
                    .and_then(|mut m| {
                        let res = m.as_result();
                        if let Err(e) = res {
                            Err(e)
                        } else {
                            Ok(m)
                        }
                    }).and_then(|_m| {
                        let mut i = _m.iter_init();
                        let properties: ::std::collections::HashMap<String, arg::Variant<Box<dyn arg::RefArg + 'static>>> =
                        match i.read() {
                            Err(_e) => {
                                return Err(DbusError::new_custom("org.freedesktop.DBus.Failed", "type mismatch"));
                            },
                            Ok(o) => o
                        };
                        Ok(properties)
                    })
        });
        Box::new(get_properties_fut)
    }

    fn set_property<I1: arg::Arg + arg::Append>(&self, name: &str, value: arg::Variant<I1>) -> Box<dyn Future<Item=(), Error=Self::Err>> {
        let mut msg = Message::method_call(&self.dest, &self.path, &"net.connman.Service".into(), &"SetProperty".into());
        {
            let mut i = arg::IterAppend::new(&mut msg);
            i.append(name);
            i.append(value);
        }
        let set_property_fut = self.conn
            .method_call(msg)
            .into_future()
            .map_err(|_e| DbusError::new_custom("org.freedesktop.DBus.Failed", "failed to call method"))
            .and_then(|amethodcall| {
                amethodcall
                    .and_then(|mut m| {
                        let res = m.as_result();
                        if let Err(e) = res {
                            Err(e)
                        } else {
                            Ok(m)
                        }
                    }).and_then(|_m| {
                        Ok(())
                    })
        });
        Box::new(set_property_fut)
    }

    fn clear_property(&self, name: &str) -> Box<dyn Future<Item=(), Error=Self::Err>> {
        let mut msg = Message::method_call(&self.dest, &self.path, &"net.connman.Service".into(), &"ClearProperty".into());
        {
            let mut i = arg::IterAppend::new(&mut msg);
            i.append(name);
        }
        let clear_property_fut = self.conn
            .method_call(msg)
            .into_future()
            .map_err(|_e| DbusError::new_custom("org.freedesktop.DBus.Failed", "failed to call method"))
            .and_then(|amethodcall| {
                amethodcall
                    .and_then(|mut m| {
                        let res = m.as_result();
                        if let Err(e) = res {
                            Err(e)
                        } else {
                            Ok(m)
                        }
                    }).and_then(|_m| {
                        Ok(())
                    })
        });
        Box::new(clear_property_fut)
    }

    fn connect(&self) -> Box<dyn Future<Item=(), Error=Self::Err>> {
        let msg = Message::method_call(&self.dest, &self.path, &"net.connman.Service".into(), &"Connect".into());
        let connect_fut = self.conn
            .method_call(msg)
            .into_future()
            .map_err(|_e| DbusError::new_custom("org.freedesktop.DBus.Failed", "failed to call method"))
            .and_then(|amethodcall| {
                amethodcall
                    .and_then(|mut m| {
                        let res = m.as_result();
                        if let Err(e) = res {
                            Err(e)
                        } else {
                            Ok(m)
                        }
                    }).and_then(|_m| {
                        Ok(())
                    })
        });
        Box::new(connect_fut)
    }

    fn disconnect(&self) -> Box<dyn Future<Item=(), Error=Self::Err>> {
        let msg = Message::method_call(&self.dest, &self.path, &"net.connman.Service".into(), &"Disconnect".into());
        let disconnect_fut = self.conn
            .method_call(msg)
            .into_future()
            .map_err(|_e| DbusError::new_custom("org.freedesktop.DBus.Failed", "failed to call method"))
            .and_then(|amethodcall| {
                amethodcall
                    .and_then(|mut m| {
                        let res = m.as_result();
                        if let Err(e) = res {
                            Err(e)
                        } else {
                            Ok(m)
                        }
                    }).and_then(|_m| {
                        Ok(())
                    })
        });
        Box::new(disconnect_fut)
    }

    fn remove(&self) -> Box<dyn Future<Item=(), Error=Self::Err>> {
        let msg = Message::method_call(&self.dest, &self.path, &"net.connman.Service".into(), &"Remove".into());
        let remove_fut = self.conn
            .method_call(msg)
            .into_future()
            .map_err(|_e| DbusError::new_custom("org.freedesktop.DBus.Failed", "failed to call method"))
            .and_then(|amethodcall| {
                amethodcall
                    .and_then(|mut m| {
                        let res = m.as_result();
                        if let Err(e) = res {
                            Err(e)
                        } else {
                            Ok(m)
                        }
                    }).and_then(|_m| {
                        Ok(())
                    })
        });
        Box::new(remove_fut)
    }

    fn move_before(&self, service: dbus::Path) -> Box<dyn Future<Item=(), Error=Self::Err>> {
        let mut msg = Message::method_call(&self.dest, &self.path, &"net.connman.Service".into(), &"MoveBefore".into());
        {
            let mut i = arg::IterAppend::new(&mut msg);
            i.append(service);
        }
        let move_before_fut = self.conn
            .method_call(msg)
            .into_future()
            .map_err(|_e| DbusError::new_custom("org.freedesktop.DBus.Failed", "failed to call method"))
            .and_then(|amethodcall| {
                amethodcall
                    .and_then(|mut m| {
                        let res = m.as_result();
                        if let Err(e) = res {
                            Err(e)
                        } else {
                            Ok(m)
                        }
                    }).and_then(|_m| {
                        Ok(())
                    })
        });
        Box::new(move_before_fut)
    }

    fn move_after(&self, service: dbus::Path) -> Box<dyn Future<Item=(), Error=Self::Err>> {
        let mut msg = Message::method_call(&self.dest, &self.path, &"net.connman.Service".into(), &"MoveAfter".into());
        {
            let mut i = arg::IterAppend::new(&mut msg);
            i.append(service);
        }
        let move_after_fut = self.conn
            .method_call(msg)
            .into_future()
            .map_err(|_e| DbusError::new_custom("org.freedesktop.DBus.Failed", "failed to call method"))
            .and_then(|amethodcall| {
                amethodcall
                    .and_then(|mut m| {
                        let res = m.as_result();
                        if let Err(e) = res {
                            Err(e)
                        } else {
                            Ok(m)
                        }
                    }).and_then(|_m| {
                        Ok(())
                    })
        });
        Box::new(move_after_fut)
    }

    fn reset_counters(&self) -> Box<dyn Future<Item=(), Error=Self::Err>> {
        let msg = Message::method_call(&self.dest, &self.path, &"net.connman.Service".into(), &"ResetCounters".into());
        let reset_counters_fut = self.conn
            .method_call(msg)
            .into_future()
            .map_err(|_e| DbusError::new_custom("org.freedesktop.DBus.Failed", "failed to call method"))
            .and_then(|amethodcall| {
                amethodcall
                    .and_then(|mut m| {
                        let res = m.as_result();
                        if let Err(e) = res {
                            Err(e)
                        } else {
                            Ok(m)
                        }
                    }).and_then(|_m| {
                        Ok(())
                    })
        });
        Box::new(reset_counters_fut)
    }
}

#[derive(Debug, Default)]
pub struct ServicePropertyChanged {
    pub name: String,
    pub value: arg::Variant<Box<dyn arg::RefArg + 'static>>,
}

impl dbus::SignalArgs for ServicePropertyChanged {
    const NAME: &'static str = "PropertyChanged";
    const INTERFACE: &'static str = "net.connman.Service";
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.name, i);
        arg::RefArg::append(&self.value, i);
    }
    fn get(&mut self, i: &mut arg::Iter) -> Result<(), arg::TypeMismatchError> {
        self.name = i.read()?;
        self.value = i.read()?;
        Ok(())
    }
}
