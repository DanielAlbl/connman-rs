// This code was autogenerated with dbus-codegen-rust, see https://github.com/diwic/dbus-rs

use dbus as dbus;
use dbus::arg;
use dbus::Message;
use dbus_tokio::AConnection;
use dbus::Error as DbusError;
use futures::Future;
use futures::future::IntoFuture;
use std::boxed::Box;
use qutex::Qutex;

pub trait OrgFreedesktopDBusIntrospectable {
    type Err;
    fn introspect(&self) -> Box<Future<Item=String, Error=Self::Err>>;
}

impl<'a> OrgFreedesktopDBusIntrospectable for dbus::ConnPath<'a, Qutex<AConnection>> {
    type Err = DbusError;

    fn introspect(&self) -> Box<Future<Item=String, Error=Self::Err>> {
        let msg = Message::method_call(&self.dest, &self.path, &"org.freedesktop.DBus.Introspectable".into(), &"Introspect".into());
        let introspect_fut = self.conn.clone().lock().map_err(|_e| DbusError::new_custom("org.freedesktop.DBus.Failed", "failed to acquire lock")).and_then(|conn| conn.method_call(msg)
            .into_future()
            .map_err(|_e| DbusError::new_custom("org.freedesktop.DBus.Failed", "failed to call method"))
            .and_then(|amethodcall| {
                amethodcall
                    .and_then(|mut m| {
                        let res = m.as_result();
                        if let Err(e) = res {
                            Err(e)
                        } else {
                            Ok(m)
                        }
                    }).and_then(|_m| {
                        let mut i = _m.iter_init();
                        let xml: String =
                        match i.read() {
                            Err(_e) => {
                                return Err(DbusError::new_custom("org.freedesktop.DBus.Failed", "type mismatch"));
                            },
                            Ok(o) => o
                        };
                        Ok(xml)
                    })
        }));
        Box::new(introspect_fut)
    }
}

pub trait Technology {
    type Err;
    fn get_properties(&self) -> Box<Future<Item=::std::collections::HashMap<String, arg::Variant<Box<arg::RefArg + 'static>>>, Error=Self::Err>>;
    fn set_property<I1: arg::Arg + arg::Append>(&self, name: &str, value: arg::Variant<I1>) -> Box<Future<Item=(), Error=Self::Err>>;
    fn scan(&self) -> Box<Future<Item=(), Error=Self::Err>>;
}

impl<'a> Technology for dbus::ConnPath<'a, Qutex<AConnection>> {
    type Err = DbusError;

    fn get_properties(&self) -> Box<Future<Item=::std::collections::HashMap<String, arg::Variant<Box<arg::RefArg + 'static>>>, Error=Self::Err>> {
        let msg = Message::method_call(&self.dest, &self.path, &"net.connman.Technology".into(), &"GetProperties".into());
        let get_properties_fut = self.conn.clone().lock().map_err(|_e| DbusError::new_custom("org.freedesktop.DBus.Failed", "failed to acquire lock")).and_then(|conn| conn.method_call(msg)
            .into_future()
            .map_err(|_e| DbusError::new_custom("org.freedesktop.DBus.Failed", "failed to call method"))
            .and_then(|amethodcall| {
                amethodcall
                    .and_then(|mut m| {
                        let res = m.as_result();
                        if let Err(e) = res {
                            Err(e)
                        } else {
                            Ok(m)
                        }
                    }).and_then(|_m| {
                        let mut i = _m.iter_init();
                        let properties: ::std::collections::HashMap<String, arg::Variant<Box<arg::RefArg + 'static>>> =
                        match i.read() {
                            Err(_e) => {
                                return Err(DbusError::new_custom("org.freedesktop.DBus.Failed", "type mismatch"));
                            },
                            Ok(o) => o
                        };
                        Ok(properties)
                    })
        }));
        Box::new(get_properties_fut)
    }

    fn set_property<I1: arg::Arg + arg::Append>(&self, name: &str, value: arg::Variant<I1>) -> Box<Future<Item=(), Error=Self::Err>> {
        let mut msg = Message::method_call(&self.dest, &self.path, &"net.connman.Technology".into(), &"SetProperty".into());
        {
            let mut i = arg::IterAppend::new(&mut msg);
            i.append(name);
            i.append(value);
        }
        let set_property_fut = self.conn.clone().lock().map_err(|_e| DbusError::new_custom("org.freedesktop.DBus.Failed", "failed to acquire lock")).and_then(|conn| conn.method_call(msg)
            .into_future()
            .map_err(|_e| DbusError::new_custom("org.freedesktop.DBus.Failed", "failed to call method"))
            .and_then(|amethodcall| {
                amethodcall
                    .and_then(|mut m| {
                        let res = m.as_result();
                        if let Err(e) = res {
                            Err(e)
                        } else {
                            Ok(m)
                        }
                    }).and_then(|_m| {
                        Ok(())
                    })
        }));
        Box::new(set_property_fut)
    }

    fn scan(&self) -> Box<Future<Item=(), Error=Self::Err>> {
        let msg = Message::method_call(&self.dest, &self.path, &"net.connman.Technology".into(), &"Scan".into());
        let scan_fut = self.conn.clone().lock().map_err(|_e| DbusError::new_custom("org.freedesktop.DBus.Failed", "failed to acquire lock")).and_then(|conn| conn.method_call(msg)
            .into_future()
            .map_err(|_e| DbusError::new_custom("org.freedesktop.DBus.Failed", "failed to call method"))
            .and_then(|amethodcall| {
                amethodcall
                    .and_then(|mut m| {
                        let res = m.as_result();
                        if let Err(e) = res {
                            Err(e)
                        } else {
                            Ok(m)
                        }
                    }).and_then(|_m| {
                        Ok(())
                    })
        }));
        Box::new(scan_fut)
    }
}

#[derive(Debug, Default)]
pub struct TechnologyPropertyChanged {
    pub name: String,
    pub value: arg::Variant<Box<arg::RefArg + 'static>>,
}

impl dbus::SignalArgs for TechnologyPropertyChanged {
    const NAME: &'static str = "PropertyChanged";
    const INTERFACE: &'static str = "net.connman.Technology";
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.name, i);
        arg::RefArg::append(&self.value, i);
    }
    fn get(&mut self, i: &mut arg::Iter) -> Result<(), arg::TypeMismatchError> {
        self.name = i.read()?;
        self.value = i.read()?;
        Ok(())
    }
}
